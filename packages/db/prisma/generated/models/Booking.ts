/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck
/**
 * This file exports the `Booking` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library";
import type * as $Enums from "../enums";
import type * as Prisma from "../internal/prismaNamespace";

/**
 * Model Booking
 *
 */
export type BookingModel =
	runtime.Types.Result.DefaultSelection<Prisma.$BookingPayload>;

export type AggregateBooking = {
	_count: BookingCountAggregateOutputType | null;
	_avg: BookingAvgAggregateOutputType | null;
	_sum: BookingSumAggregateOutputType | null;
	_min: BookingMinAggregateOutputType | null;
	_max: BookingMaxAggregateOutputType | null;
};

export type BookingAvgAggregateOutputType = {
	sourceLat: number | null;
	sourceLong: number | null;
	destLat: number | null;
	destLong: number | null;
	distanceKm: number | null;
	fare: number | null;
	rating: number | null;
};

export type BookingSumAggregateOutputType = {
	sourceLat: number | null;
	sourceLong: number | null;
	destLat: number | null;
	destLong: number | null;
	distanceKm: number | null;
	fare: number | null;
	rating: number | null;
};

export type BookingMinAggregateOutputType = {
	id: string | null;
	passengerId: string | null;
	driverId: string | null;
	sourceLat: number | null;
	sourceLong: number | null;
	destLat: number | null;
	destLong: number | null;
	distanceKm: number | null;
	fare: number | null;
	currency: string | null;
	status: $Enums.BookingStatus | null;
	requestedAt: Date | null;
	acceptedAt: Date | null;
	startedAt: Date | null;
	completedAt: Date | null;
	cancelledAt: Date | null;
	rating: number | null;
	feedback: string | null;
};

export type BookingMaxAggregateOutputType = {
	id: string | null;
	passengerId: string | null;
	driverId: string | null;
	sourceLat: number | null;
	sourceLong: number | null;
	destLat: number | null;
	destLong: number | null;
	distanceKm: number | null;
	fare: number | null;
	currency: string | null;
	status: $Enums.BookingStatus | null;
	requestedAt: Date | null;
	acceptedAt: Date | null;
	startedAt: Date | null;
	completedAt: Date | null;
	cancelledAt: Date | null;
	rating: number | null;
	feedback: string | null;
};

export type BookingCountAggregateOutputType = {
	id: number;
	passengerId: number;
	driverId: number;
	sourceLat: number;
	sourceLong: number;
	destLat: number;
	destLong: number;
	distanceKm: number;
	fare: number;
	currency: number;
	status: number;
	requestedAt: number;
	acceptedAt: number;
	startedAt: number;
	completedAt: number;
	cancelledAt: number;
	rating: number;
	feedback: number;
	metadata: number;
	_all: number;
};

export type BookingAvgAggregateInputType = {
	sourceLat?: true;
	sourceLong?: true;
	destLat?: true;
	destLong?: true;
	distanceKm?: true;
	fare?: true;
	rating?: true;
};

export type BookingSumAggregateInputType = {
	sourceLat?: true;
	sourceLong?: true;
	destLat?: true;
	destLong?: true;
	distanceKm?: true;
	fare?: true;
	rating?: true;
};

export type BookingMinAggregateInputType = {
	id?: true;
	passengerId?: true;
	driverId?: true;
	sourceLat?: true;
	sourceLong?: true;
	destLat?: true;
	destLong?: true;
	distanceKm?: true;
	fare?: true;
	currency?: true;
	status?: true;
	requestedAt?: true;
	acceptedAt?: true;
	startedAt?: true;
	completedAt?: true;
	cancelledAt?: true;
	rating?: true;
	feedback?: true;
};

export type BookingMaxAggregateInputType = {
	id?: true;
	passengerId?: true;
	driverId?: true;
	sourceLat?: true;
	sourceLong?: true;
	destLat?: true;
	destLong?: true;
	distanceKm?: true;
	fare?: true;
	currency?: true;
	status?: true;
	requestedAt?: true;
	acceptedAt?: true;
	startedAt?: true;
	completedAt?: true;
	cancelledAt?: true;
	rating?: true;
	feedback?: true;
};

export type BookingCountAggregateInputType = {
	id?: true;
	passengerId?: true;
	driverId?: true;
	sourceLat?: true;
	sourceLong?: true;
	destLat?: true;
	destLong?: true;
	distanceKm?: true;
	fare?: true;
	currency?: true;
	status?: true;
	requestedAt?: true;
	acceptedAt?: true;
	startedAt?: true;
	completedAt?: true;
	cancelledAt?: true;
	rating?: true;
	feedback?: true;
	metadata?: true;
	_all?: true;
};

export type BookingAggregateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which Booking to aggregate.
	 */
	where?: Prisma.BookingWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Bookings to fetch.
	 */
	orderBy?:
		| Prisma.BookingOrderByWithRelationInput
		| Prisma.BookingOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the start position
	 */
	cursor?: Prisma.BookingWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Bookings from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Bookings.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Count returned Bookings
	 **/
	_count?: true | BookingCountAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to average
	 **/
	_avg?: BookingAvgAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to sum
	 **/
	_sum?: BookingSumAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the minimum value
	 **/
	_min?: BookingMinAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the maximum value
	 **/
	_max?: BookingMaxAggregateInputType;
};

export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
	[P in keyof T & keyof AggregateBooking]: P extends "_count" | "count"
		? T[P] extends true
			? number
			: Prisma.GetScalarType<T[P], AggregateBooking[P]>
		: Prisma.GetScalarType<T[P], AggregateBooking[P]>;
};

export type BookingGroupByArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.BookingWhereInput;
	orderBy?:
		| Prisma.BookingOrderByWithAggregationInput
		| Prisma.BookingOrderByWithAggregationInput[];
	by: Prisma.BookingScalarFieldEnum[] | Prisma.BookingScalarFieldEnum;
	having?: Prisma.BookingScalarWhereWithAggregatesInput;
	take?: number;
	skip?: number;
	_count?: BookingCountAggregateInputType | true;
	_avg?: BookingAvgAggregateInputType;
	_sum?: BookingSumAggregateInputType;
	_min?: BookingMinAggregateInputType;
	_max?: BookingMaxAggregateInputType;
};

export type BookingGroupByOutputType = {
	id: string;
	passengerId: string;
	driverId: string | null;
	sourceLat: number;
	sourceLong: number;
	destLat: number;
	destLong: number;
	distanceKm: number | null;
	fare: number | null;
	currency: string;
	status: $Enums.BookingStatus;
	requestedAt: Date;
	acceptedAt: Date | null;
	startedAt: Date | null;
	completedAt: Date | null;
	cancelledAt: Date | null;
	rating: number | null;
	feedback: string | null;
	metadata: runtime.JsonValue | null;
	_count: BookingCountAggregateOutputType | null;
	_avg: BookingAvgAggregateOutputType | null;
	_sum: BookingSumAggregateOutputType | null;
	_min: BookingMinAggregateOutputType | null;
	_max: BookingMaxAggregateOutputType | null;
};

type GetBookingGroupByPayload<T extends BookingGroupByArgs> =
	Prisma.PrismaPromise<
		Array<
			Prisma.PickEnumerable<BookingGroupByOutputType, T["by"]> & {
				[P in keyof T & keyof BookingGroupByOutputType]: P extends "_count"
					? T[P] extends boolean
						? number
						: Prisma.GetScalarType<T[P], BookingGroupByOutputType[P]>
					: Prisma.GetScalarType<T[P], BookingGroupByOutputType[P]>;
			}
		>
	>;

export type BookingWhereInput = {
	AND?: Prisma.BookingWhereInput | Prisma.BookingWhereInput[];
	OR?: Prisma.BookingWhereInput[];
	NOT?: Prisma.BookingWhereInput | Prisma.BookingWhereInput[];
	id?: Prisma.StringFilter<"Booking"> | string;
	passengerId?: Prisma.StringFilter<"Booking"> | string;
	driverId?: Prisma.StringNullableFilter<"Booking"> | string | null;
	sourceLat?: Prisma.FloatFilter<"Booking"> | number;
	sourceLong?: Prisma.FloatFilter<"Booking"> | number;
	destLat?: Prisma.FloatFilter<"Booking"> | number;
	destLong?: Prisma.FloatFilter<"Booking"> | number;
	distanceKm?: Prisma.FloatNullableFilter<"Booking"> | number | null;
	fare?: Prisma.IntNullableFilter<"Booking"> | number | null;
	currency?: Prisma.StringFilter<"Booking"> | string;
	status?: Prisma.EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus;
	requestedAt?: Prisma.DateTimeFilter<"Booking"> | Date | string;
	acceptedAt?: Prisma.DateTimeNullableFilter<"Booking"> | Date | string | null;
	startedAt?: Prisma.DateTimeNullableFilter<"Booking"> | Date | string | null;
	completedAt?: Prisma.DateTimeNullableFilter<"Booking"> | Date | string | null;
	cancelledAt?: Prisma.DateTimeNullableFilter<"Booking"> | Date | string | null;
	rating?: Prisma.IntNullableFilter<"Booking"> | number | null;
	feedback?: Prisma.StringNullableFilter<"Booking"> | string | null;
	metadata?: Prisma.JsonNullableFilter<"Booking">;
	passenger?: Prisma.XOR<
		Prisma.UserScalarRelationFilter,
		Prisma.UserWhereInput
	>;
	driver?: Prisma.XOR<
		Prisma.UserNullableScalarRelationFilter,
		Prisma.UserWhereInput
	> | null;
};

export type BookingOrderByWithRelationInput = {
	id?: Prisma.SortOrder;
	passengerId?: Prisma.SortOrder;
	driverId?: Prisma.SortOrderInput | Prisma.SortOrder;
	sourceLat?: Prisma.SortOrder;
	sourceLong?: Prisma.SortOrder;
	destLat?: Prisma.SortOrder;
	destLong?: Prisma.SortOrder;
	distanceKm?: Prisma.SortOrderInput | Prisma.SortOrder;
	fare?: Prisma.SortOrderInput | Prisma.SortOrder;
	currency?: Prisma.SortOrder;
	status?: Prisma.SortOrder;
	requestedAt?: Prisma.SortOrder;
	acceptedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
	startedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
	completedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
	cancelledAt?: Prisma.SortOrderInput | Prisma.SortOrder;
	rating?: Prisma.SortOrderInput | Prisma.SortOrder;
	feedback?: Prisma.SortOrderInput | Prisma.SortOrder;
	metadata?: Prisma.SortOrderInput | Prisma.SortOrder;
	passenger?: Prisma.UserOrderByWithRelationInput;
	driver?: Prisma.UserOrderByWithRelationInput;
};

export type BookingWhereUniqueInput = Prisma.AtLeast<
	{
		id?: string;
		AND?: Prisma.BookingWhereInput | Prisma.BookingWhereInput[];
		OR?: Prisma.BookingWhereInput[];
		NOT?: Prisma.BookingWhereInput | Prisma.BookingWhereInput[];
		passengerId?: Prisma.StringFilter<"Booking"> | string;
		driverId?: Prisma.StringNullableFilter<"Booking"> | string | null;
		sourceLat?: Prisma.FloatFilter<"Booking"> | number;
		sourceLong?: Prisma.FloatFilter<"Booking"> | number;
		destLat?: Prisma.FloatFilter<"Booking"> | number;
		destLong?: Prisma.FloatFilter<"Booking"> | number;
		distanceKm?: Prisma.FloatNullableFilter<"Booking"> | number | null;
		fare?: Prisma.IntNullableFilter<"Booking"> | number | null;
		currency?: Prisma.StringFilter<"Booking"> | string;
		status?: Prisma.EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus;
		requestedAt?: Prisma.DateTimeFilter<"Booking"> | Date | string;
		acceptedAt?:
			| Prisma.DateTimeNullableFilter<"Booking">
			| Date
			| string
			| null;
		startedAt?: Prisma.DateTimeNullableFilter<"Booking"> | Date | string | null;
		completedAt?:
			| Prisma.DateTimeNullableFilter<"Booking">
			| Date
			| string
			| null;
		cancelledAt?:
			| Prisma.DateTimeNullableFilter<"Booking">
			| Date
			| string
			| null;
		rating?: Prisma.IntNullableFilter<"Booking"> | number | null;
		feedback?: Prisma.StringNullableFilter<"Booking"> | string | null;
		metadata?: Prisma.JsonNullableFilter<"Booking">;
		passenger?: Prisma.XOR<
			Prisma.UserScalarRelationFilter,
			Prisma.UserWhereInput
		>;
		driver?: Prisma.XOR<
			Prisma.UserNullableScalarRelationFilter,
			Prisma.UserWhereInput
		> | null;
	},
	"id"
>;

export type BookingOrderByWithAggregationInput = {
	id?: Prisma.SortOrder;
	passengerId?: Prisma.SortOrder;
	driverId?: Prisma.SortOrderInput | Prisma.SortOrder;
	sourceLat?: Prisma.SortOrder;
	sourceLong?: Prisma.SortOrder;
	destLat?: Prisma.SortOrder;
	destLong?: Prisma.SortOrder;
	distanceKm?: Prisma.SortOrderInput | Prisma.SortOrder;
	fare?: Prisma.SortOrderInput | Prisma.SortOrder;
	currency?: Prisma.SortOrder;
	status?: Prisma.SortOrder;
	requestedAt?: Prisma.SortOrder;
	acceptedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
	startedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
	completedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
	cancelledAt?: Prisma.SortOrderInput | Prisma.SortOrder;
	rating?: Prisma.SortOrderInput | Prisma.SortOrder;
	feedback?: Prisma.SortOrderInput | Prisma.SortOrder;
	metadata?: Prisma.SortOrderInput | Prisma.SortOrder;
	_count?: Prisma.BookingCountOrderByAggregateInput;
	_avg?: Prisma.BookingAvgOrderByAggregateInput;
	_max?: Prisma.BookingMaxOrderByAggregateInput;
	_min?: Prisma.BookingMinOrderByAggregateInput;
	_sum?: Prisma.BookingSumOrderByAggregateInput;
};

export type BookingScalarWhereWithAggregatesInput = {
	AND?:
		| Prisma.BookingScalarWhereWithAggregatesInput
		| Prisma.BookingScalarWhereWithAggregatesInput[];
	OR?: Prisma.BookingScalarWhereWithAggregatesInput[];
	NOT?:
		| Prisma.BookingScalarWhereWithAggregatesInput
		| Prisma.BookingScalarWhereWithAggregatesInput[];
	id?: Prisma.StringWithAggregatesFilter<"Booking"> | string;
	passengerId?: Prisma.StringWithAggregatesFilter<"Booking"> | string;
	driverId?:
		| Prisma.StringNullableWithAggregatesFilter<"Booking">
		| string
		| null;
	sourceLat?: Prisma.FloatWithAggregatesFilter<"Booking"> | number;
	sourceLong?: Prisma.FloatWithAggregatesFilter<"Booking"> | number;
	destLat?: Prisma.FloatWithAggregatesFilter<"Booking"> | number;
	destLong?: Prisma.FloatWithAggregatesFilter<"Booking"> | number;
	distanceKm?:
		| Prisma.FloatNullableWithAggregatesFilter<"Booking">
		| number
		| null;
	fare?: Prisma.IntNullableWithAggregatesFilter<"Booking"> | number | null;
	currency?: Prisma.StringWithAggregatesFilter<"Booking"> | string;
	status?:
		| Prisma.EnumBookingStatusWithAggregatesFilter<"Booking">
		| $Enums.BookingStatus;
	requestedAt?: Prisma.DateTimeWithAggregatesFilter<"Booking"> | Date | string;
	acceptedAt?:
		| Prisma.DateTimeNullableWithAggregatesFilter<"Booking">
		| Date
		| string
		| null;
	startedAt?:
		| Prisma.DateTimeNullableWithAggregatesFilter<"Booking">
		| Date
		| string
		| null;
	completedAt?:
		| Prisma.DateTimeNullableWithAggregatesFilter<"Booking">
		| Date
		| string
		| null;
	cancelledAt?:
		| Prisma.DateTimeNullableWithAggregatesFilter<"Booking">
		| Date
		| string
		| null;
	rating?: Prisma.IntNullableWithAggregatesFilter<"Booking"> | number | null;
	feedback?:
		| Prisma.StringNullableWithAggregatesFilter<"Booking">
		| string
		| null;
	metadata?: Prisma.JsonNullableWithAggregatesFilter<"Booking">;
};

export type BookingCreateInput = {
	id?: string;
	sourceLat: number;
	sourceLong: number;
	destLat: number;
	destLong: number;
	distanceKm?: number | null;
	fare?: number | null;
	currency?: string;
	status?: $Enums.BookingStatus;
	requestedAt?: Date | string;
	acceptedAt?: Date | string | null;
	startedAt?: Date | string | null;
	completedAt?: Date | string | null;
	cancelledAt?: Date | string | null;
	rating?: number | null;
	feedback?: string | null;
	metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	passenger: Prisma.UserCreateNestedOneWithoutPassengerBookingsInput;
	driver?: Prisma.UserCreateNestedOneWithoutDriverBookingsInput;
};

export type BookingUncheckedCreateInput = {
	id?: string;
	passengerId: string;
	driverId?: string | null;
	sourceLat: number;
	sourceLong: number;
	destLat: number;
	destLong: number;
	distanceKm?: number | null;
	fare?: number | null;
	currency?: string;
	status?: $Enums.BookingStatus;
	requestedAt?: Date | string;
	acceptedAt?: Date | string | null;
	startedAt?: Date | string | null;
	completedAt?: Date | string | null;
	cancelledAt?: Date | string | null;
	rating?: number | null;
	feedback?: string | null;
	metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
};

export type BookingUpdateInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	sourceLat?: Prisma.FloatFieldUpdateOperationsInput | number;
	sourceLong?: Prisma.FloatFieldUpdateOperationsInput | number;
	destLat?: Prisma.FloatFieldUpdateOperationsInput | number;
	destLong?: Prisma.FloatFieldUpdateOperationsInput | number;
	distanceKm?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	fare?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	currency?: Prisma.StringFieldUpdateOperationsInput | string;
	status?:
		| Prisma.EnumBookingStatusFieldUpdateOperationsInput
		| $Enums.BookingStatus;
	requestedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	acceptedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	startedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	completedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	cancelledAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	rating?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	feedback?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	passenger?: Prisma.UserUpdateOneRequiredWithoutPassengerBookingsNestedInput;
	driver?: Prisma.UserUpdateOneWithoutDriverBookingsNestedInput;
};

export type BookingUncheckedUpdateInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	passengerId?: Prisma.StringFieldUpdateOperationsInput | string;
	driverId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	sourceLat?: Prisma.FloatFieldUpdateOperationsInput | number;
	sourceLong?: Prisma.FloatFieldUpdateOperationsInput | number;
	destLat?: Prisma.FloatFieldUpdateOperationsInput | number;
	destLong?: Prisma.FloatFieldUpdateOperationsInput | number;
	distanceKm?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	fare?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	currency?: Prisma.StringFieldUpdateOperationsInput | string;
	status?:
		| Prisma.EnumBookingStatusFieldUpdateOperationsInput
		| $Enums.BookingStatus;
	requestedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	acceptedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	startedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	completedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	cancelledAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	rating?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	feedback?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
};

export type BookingCreateManyInput = {
	id?: string;
	passengerId: string;
	driverId?: string | null;
	sourceLat: number;
	sourceLong: number;
	destLat: number;
	destLong: number;
	distanceKm?: number | null;
	fare?: number | null;
	currency?: string;
	status?: $Enums.BookingStatus;
	requestedAt?: Date | string;
	acceptedAt?: Date | string | null;
	startedAt?: Date | string | null;
	completedAt?: Date | string | null;
	cancelledAt?: Date | string | null;
	rating?: number | null;
	feedback?: string | null;
	metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
};

export type BookingUpdateManyMutationInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	sourceLat?: Prisma.FloatFieldUpdateOperationsInput | number;
	sourceLong?: Prisma.FloatFieldUpdateOperationsInput | number;
	destLat?: Prisma.FloatFieldUpdateOperationsInput | number;
	destLong?: Prisma.FloatFieldUpdateOperationsInput | number;
	distanceKm?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	fare?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	currency?: Prisma.StringFieldUpdateOperationsInput | string;
	status?:
		| Prisma.EnumBookingStatusFieldUpdateOperationsInput
		| $Enums.BookingStatus;
	requestedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	acceptedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	startedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	completedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	cancelledAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	rating?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	feedback?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
};

export type BookingUncheckedUpdateManyInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	passengerId?: Prisma.StringFieldUpdateOperationsInput | string;
	driverId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	sourceLat?: Prisma.FloatFieldUpdateOperationsInput | number;
	sourceLong?: Prisma.FloatFieldUpdateOperationsInput | number;
	destLat?: Prisma.FloatFieldUpdateOperationsInput | number;
	destLong?: Prisma.FloatFieldUpdateOperationsInput | number;
	distanceKm?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	fare?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	currency?: Prisma.StringFieldUpdateOperationsInput | string;
	status?:
		| Prisma.EnumBookingStatusFieldUpdateOperationsInput
		| $Enums.BookingStatus;
	requestedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	acceptedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	startedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	completedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	cancelledAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	rating?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	feedback?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
};

export type BookingListRelationFilter = {
	every?: Prisma.BookingWhereInput;
	some?: Prisma.BookingWhereInput;
	none?: Prisma.BookingWhereInput;
};

export type BookingOrderByRelationAggregateInput = {
	_count?: Prisma.SortOrder;
};

export type BookingCountOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	passengerId?: Prisma.SortOrder;
	driverId?: Prisma.SortOrder;
	sourceLat?: Prisma.SortOrder;
	sourceLong?: Prisma.SortOrder;
	destLat?: Prisma.SortOrder;
	destLong?: Prisma.SortOrder;
	distanceKm?: Prisma.SortOrder;
	fare?: Prisma.SortOrder;
	currency?: Prisma.SortOrder;
	status?: Prisma.SortOrder;
	requestedAt?: Prisma.SortOrder;
	acceptedAt?: Prisma.SortOrder;
	startedAt?: Prisma.SortOrder;
	completedAt?: Prisma.SortOrder;
	cancelledAt?: Prisma.SortOrder;
	rating?: Prisma.SortOrder;
	feedback?: Prisma.SortOrder;
	metadata?: Prisma.SortOrder;
};

export type BookingAvgOrderByAggregateInput = {
	sourceLat?: Prisma.SortOrder;
	sourceLong?: Prisma.SortOrder;
	destLat?: Prisma.SortOrder;
	destLong?: Prisma.SortOrder;
	distanceKm?: Prisma.SortOrder;
	fare?: Prisma.SortOrder;
	rating?: Prisma.SortOrder;
};

export type BookingMaxOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	passengerId?: Prisma.SortOrder;
	driverId?: Prisma.SortOrder;
	sourceLat?: Prisma.SortOrder;
	sourceLong?: Prisma.SortOrder;
	destLat?: Prisma.SortOrder;
	destLong?: Prisma.SortOrder;
	distanceKm?: Prisma.SortOrder;
	fare?: Prisma.SortOrder;
	currency?: Prisma.SortOrder;
	status?: Prisma.SortOrder;
	requestedAt?: Prisma.SortOrder;
	acceptedAt?: Prisma.SortOrder;
	startedAt?: Prisma.SortOrder;
	completedAt?: Prisma.SortOrder;
	cancelledAt?: Prisma.SortOrder;
	rating?: Prisma.SortOrder;
	feedback?: Prisma.SortOrder;
};

export type BookingMinOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	passengerId?: Prisma.SortOrder;
	driverId?: Prisma.SortOrder;
	sourceLat?: Prisma.SortOrder;
	sourceLong?: Prisma.SortOrder;
	destLat?: Prisma.SortOrder;
	destLong?: Prisma.SortOrder;
	distanceKm?: Prisma.SortOrder;
	fare?: Prisma.SortOrder;
	currency?: Prisma.SortOrder;
	status?: Prisma.SortOrder;
	requestedAt?: Prisma.SortOrder;
	acceptedAt?: Prisma.SortOrder;
	startedAt?: Prisma.SortOrder;
	completedAt?: Prisma.SortOrder;
	cancelledAt?: Prisma.SortOrder;
	rating?: Prisma.SortOrder;
	feedback?: Prisma.SortOrder;
};

export type BookingSumOrderByAggregateInput = {
	sourceLat?: Prisma.SortOrder;
	sourceLong?: Prisma.SortOrder;
	destLat?: Prisma.SortOrder;
	destLong?: Prisma.SortOrder;
	distanceKm?: Prisma.SortOrder;
	fare?: Prisma.SortOrder;
	rating?: Prisma.SortOrder;
};

export type BookingCreateNestedManyWithoutPassengerInput = {
	create?:
		| Prisma.XOR<
				Prisma.BookingCreateWithoutPassengerInput,
				Prisma.BookingUncheckedCreateWithoutPassengerInput
		  >
		| Prisma.BookingCreateWithoutPassengerInput[]
		| Prisma.BookingUncheckedCreateWithoutPassengerInput[];
	connectOrCreate?:
		| Prisma.BookingCreateOrConnectWithoutPassengerInput
		| Prisma.BookingCreateOrConnectWithoutPassengerInput[];
	createMany?: Prisma.BookingCreateManyPassengerInputEnvelope;
	connect?: Prisma.BookingWhereUniqueInput | Prisma.BookingWhereUniqueInput[];
};

export type BookingCreateNestedManyWithoutDriverInput = {
	create?:
		| Prisma.XOR<
				Prisma.BookingCreateWithoutDriverInput,
				Prisma.BookingUncheckedCreateWithoutDriverInput
		  >
		| Prisma.BookingCreateWithoutDriverInput[]
		| Prisma.BookingUncheckedCreateWithoutDriverInput[];
	connectOrCreate?:
		| Prisma.BookingCreateOrConnectWithoutDriverInput
		| Prisma.BookingCreateOrConnectWithoutDriverInput[];
	createMany?: Prisma.BookingCreateManyDriverInputEnvelope;
	connect?: Prisma.BookingWhereUniqueInput | Prisma.BookingWhereUniqueInput[];
};

export type BookingUncheckedCreateNestedManyWithoutPassengerInput = {
	create?:
		| Prisma.XOR<
				Prisma.BookingCreateWithoutPassengerInput,
				Prisma.BookingUncheckedCreateWithoutPassengerInput
		  >
		| Prisma.BookingCreateWithoutPassengerInput[]
		| Prisma.BookingUncheckedCreateWithoutPassengerInput[];
	connectOrCreate?:
		| Prisma.BookingCreateOrConnectWithoutPassengerInput
		| Prisma.BookingCreateOrConnectWithoutPassengerInput[];
	createMany?: Prisma.BookingCreateManyPassengerInputEnvelope;
	connect?: Prisma.BookingWhereUniqueInput | Prisma.BookingWhereUniqueInput[];
};

export type BookingUncheckedCreateNestedManyWithoutDriverInput = {
	create?:
		| Prisma.XOR<
				Prisma.BookingCreateWithoutDriverInput,
				Prisma.BookingUncheckedCreateWithoutDriverInput
		  >
		| Prisma.BookingCreateWithoutDriverInput[]
		| Prisma.BookingUncheckedCreateWithoutDriverInput[];
	connectOrCreate?:
		| Prisma.BookingCreateOrConnectWithoutDriverInput
		| Prisma.BookingCreateOrConnectWithoutDriverInput[];
	createMany?: Prisma.BookingCreateManyDriverInputEnvelope;
	connect?: Prisma.BookingWhereUniqueInput | Prisma.BookingWhereUniqueInput[];
};

export type BookingUpdateManyWithoutPassengerNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.BookingCreateWithoutPassengerInput,
				Prisma.BookingUncheckedCreateWithoutPassengerInput
		  >
		| Prisma.BookingCreateWithoutPassengerInput[]
		| Prisma.BookingUncheckedCreateWithoutPassengerInput[];
	connectOrCreate?:
		| Prisma.BookingCreateOrConnectWithoutPassengerInput
		| Prisma.BookingCreateOrConnectWithoutPassengerInput[];
	upsert?:
		| Prisma.BookingUpsertWithWhereUniqueWithoutPassengerInput
		| Prisma.BookingUpsertWithWhereUniqueWithoutPassengerInput[];
	createMany?: Prisma.BookingCreateManyPassengerInputEnvelope;
	set?: Prisma.BookingWhereUniqueInput | Prisma.BookingWhereUniqueInput[];
	disconnect?:
		| Prisma.BookingWhereUniqueInput
		| Prisma.BookingWhereUniqueInput[];
	delete?: Prisma.BookingWhereUniqueInput | Prisma.BookingWhereUniqueInput[];
	connect?: Prisma.BookingWhereUniqueInput | Prisma.BookingWhereUniqueInput[];
	update?:
		| Prisma.BookingUpdateWithWhereUniqueWithoutPassengerInput
		| Prisma.BookingUpdateWithWhereUniqueWithoutPassengerInput[];
	updateMany?:
		| Prisma.BookingUpdateManyWithWhereWithoutPassengerInput
		| Prisma.BookingUpdateManyWithWhereWithoutPassengerInput[];
	deleteMany?:
		| Prisma.BookingScalarWhereInput
		| Prisma.BookingScalarWhereInput[];
};

export type BookingUpdateManyWithoutDriverNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.BookingCreateWithoutDriverInput,
				Prisma.BookingUncheckedCreateWithoutDriverInput
		  >
		| Prisma.BookingCreateWithoutDriverInput[]
		| Prisma.BookingUncheckedCreateWithoutDriverInput[];
	connectOrCreate?:
		| Prisma.BookingCreateOrConnectWithoutDriverInput
		| Prisma.BookingCreateOrConnectWithoutDriverInput[];
	upsert?:
		| Prisma.BookingUpsertWithWhereUniqueWithoutDriverInput
		| Prisma.BookingUpsertWithWhereUniqueWithoutDriverInput[];
	createMany?: Prisma.BookingCreateManyDriverInputEnvelope;
	set?: Prisma.BookingWhereUniqueInput | Prisma.BookingWhereUniqueInput[];
	disconnect?:
		| Prisma.BookingWhereUniqueInput
		| Prisma.BookingWhereUniqueInput[];
	delete?: Prisma.BookingWhereUniqueInput | Prisma.BookingWhereUniqueInput[];
	connect?: Prisma.BookingWhereUniqueInput | Prisma.BookingWhereUniqueInput[];
	update?:
		| Prisma.BookingUpdateWithWhereUniqueWithoutDriverInput
		| Prisma.BookingUpdateWithWhereUniqueWithoutDriverInput[];
	updateMany?:
		| Prisma.BookingUpdateManyWithWhereWithoutDriverInput
		| Prisma.BookingUpdateManyWithWhereWithoutDriverInput[];
	deleteMany?:
		| Prisma.BookingScalarWhereInput
		| Prisma.BookingScalarWhereInput[];
};

export type BookingUncheckedUpdateManyWithoutPassengerNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.BookingCreateWithoutPassengerInput,
				Prisma.BookingUncheckedCreateWithoutPassengerInput
		  >
		| Prisma.BookingCreateWithoutPassengerInput[]
		| Prisma.BookingUncheckedCreateWithoutPassengerInput[];
	connectOrCreate?:
		| Prisma.BookingCreateOrConnectWithoutPassengerInput
		| Prisma.BookingCreateOrConnectWithoutPassengerInput[];
	upsert?:
		| Prisma.BookingUpsertWithWhereUniqueWithoutPassengerInput
		| Prisma.BookingUpsertWithWhereUniqueWithoutPassengerInput[];
	createMany?: Prisma.BookingCreateManyPassengerInputEnvelope;
	set?: Prisma.BookingWhereUniqueInput | Prisma.BookingWhereUniqueInput[];
	disconnect?:
		| Prisma.BookingWhereUniqueInput
		| Prisma.BookingWhereUniqueInput[];
	delete?: Prisma.BookingWhereUniqueInput | Prisma.BookingWhereUniqueInput[];
	connect?: Prisma.BookingWhereUniqueInput | Prisma.BookingWhereUniqueInput[];
	update?:
		| Prisma.BookingUpdateWithWhereUniqueWithoutPassengerInput
		| Prisma.BookingUpdateWithWhereUniqueWithoutPassengerInput[];
	updateMany?:
		| Prisma.BookingUpdateManyWithWhereWithoutPassengerInput
		| Prisma.BookingUpdateManyWithWhereWithoutPassengerInput[];
	deleteMany?:
		| Prisma.BookingScalarWhereInput
		| Prisma.BookingScalarWhereInput[];
};

export type BookingUncheckedUpdateManyWithoutDriverNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.BookingCreateWithoutDriverInput,
				Prisma.BookingUncheckedCreateWithoutDriverInput
		  >
		| Prisma.BookingCreateWithoutDriverInput[]
		| Prisma.BookingUncheckedCreateWithoutDriverInput[];
	connectOrCreate?:
		| Prisma.BookingCreateOrConnectWithoutDriverInput
		| Prisma.BookingCreateOrConnectWithoutDriverInput[];
	upsert?:
		| Prisma.BookingUpsertWithWhereUniqueWithoutDriverInput
		| Prisma.BookingUpsertWithWhereUniqueWithoutDriverInput[];
	createMany?: Prisma.BookingCreateManyDriverInputEnvelope;
	set?: Prisma.BookingWhereUniqueInput | Prisma.BookingWhereUniqueInput[];
	disconnect?:
		| Prisma.BookingWhereUniqueInput
		| Prisma.BookingWhereUniqueInput[];
	delete?: Prisma.BookingWhereUniqueInput | Prisma.BookingWhereUniqueInput[];
	connect?: Prisma.BookingWhereUniqueInput | Prisma.BookingWhereUniqueInput[];
	update?:
		| Prisma.BookingUpdateWithWhereUniqueWithoutDriverInput
		| Prisma.BookingUpdateWithWhereUniqueWithoutDriverInput[];
	updateMany?:
		| Prisma.BookingUpdateManyWithWhereWithoutDriverInput
		| Prisma.BookingUpdateManyWithWhereWithoutDriverInput[];
	deleteMany?:
		| Prisma.BookingScalarWhereInput
		| Prisma.BookingScalarWhereInput[];
};

export type FloatFieldUpdateOperationsInput = {
	set?: number;
	increment?: number;
	decrement?: number;
	multiply?: number;
	divide?: number;
};

export type NullableFloatFieldUpdateOperationsInput = {
	set?: number | null;
	increment?: number;
	decrement?: number;
	multiply?: number;
	divide?: number;
};

export type NullableIntFieldUpdateOperationsInput = {
	set?: number | null;
	increment?: number;
	decrement?: number;
	multiply?: number;
	divide?: number;
};

export type EnumBookingStatusFieldUpdateOperationsInput = {
	set?: $Enums.BookingStatus;
};

export type BookingCreateWithoutPassengerInput = {
	id?: string;
	sourceLat: number;
	sourceLong: number;
	destLat: number;
	destLong: number;
	distanceKm?: number | null;
	fare?: number | null;
	currency?: string;
	status?: $Enums.BookingStatus;
	requestedAt?: Date | string;
	acceptedAt?: Date | string | null;
	startedAt?: Date | string | null;
	completedAt?: Date | string | null;
	cancelledAt?: Date | string | null;
	rating?: number | null;
	feedback?: string | null;
	metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	driver?: Prisma.UserCreateNestedOneWithoutDriverBookingsInput;
};

export type BookingUncheckedCreateWithoutPassengerInput = {
	id?: string;
	driverId?: string | null;
	sourceLat: number;
	sourceLong: number;
	destLat: number;
	destLong: number;
	distanceKm?: number | null;
	fare?: number | null;
	currency?: string;
	status?: $Enums.BookingStatus;
	requestedAt?: Date | string;
	acceptedAt?: Date | string | null;
	startedAt?: Date | string | null;
	completedAt?: Date | string | null;
	cancelledAt?: Date | string | null;
	rating?: number | null;
	feedback?: string | null;
	metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
};

export type BookingCreateOrConnectWithoutPassengerInput = {
	where: Prisma.BookingWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.BookingCreateWithoutPassengerInput,
		Prisma.BookingUncheckedCreateWithoutPassengerInput
	>;
};

export type BookingCreateManyPassengerInputEnvelope = {
	data:
		| Prisma.BookingCreateManyPassengerInput
		| Prisma.BookingCreateManyPassengerInput[];
	skipDuplicates?: boolean;
};

export type BookingCreateWithoutDriverInput = {
	id?: string;
	sourceLat: number;
	sourceLong: number;
	destLat: number;
	destLong: number;
	distanceKm?: number | null;
	fare?: number | null;
	currency?: string;
	status?: $Enums.BookingStatus;
	requestedAt?: Date | string;
	acceptedAt?: Date | string | null;
	startedAt?: Date | string | null;
	completedAt?: Date | string | null;
	cancelledAt?: Date | string | null;
	rating?: number | null;
	feedback?: string | null;
	metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	passenger: Prisma.UserCreateNestedOneWithoutPassengerBookingsInput;
};

export type BookingUncheckedCreateWithoutDriverInput = {
	id?: string;
	passengerId: string;
	sourceLat: number;
	sourceLong: number;
	destLat: number;
	destLong: number;
	distanceKm?: number | null;
	fare?: number | null;
	currency?: string;
	status?: $Enums.BookingStatus;
	requestedAt?: Date | string;
	acceptedAt?: Date | string | null;
	startedAt?: Date | string | null;
	completedAt?: Date | string | null;
	cancelledAt?: Date | string | null;
	rating?: number | null;
	feedback?: string | null;
	metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
};

export type BookingCreateOrConnectWithoutDriverInput = {
	where: Prisma.BookingWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.BookingCreateWithoutDriverInput,
		Prisma.BookingUncheckedCreateWithoutDriverInput
	>;
};

export type BookingCreateManyDriverInputEnvelope = {
	data:
		| Prisma.BookingCreateManyDriverInput
		| Prisma.BookingCreateManyDriverInput[];
	skipDuplicates?: boolean;
};

export type BookingUpsertWithWhereUniqueWithoutPassengerInput = {
	where: Prisma.BookingWhereUniqueInput;
	update: Prisma.XOR<
		Prisma.BookingUpdateWithoutPassengerInput,
		Prisma.BookingUncheckedUpdateWithoutPassengerInput
	>;
	create: Prisma.XOR<
		Prisma.BookingCreateWithoutPassengerInput,
		Prisma.BookingUncheckedCreateWithoutPassengerInput
	>;
};

export type BookingUpdateWithWhereUniqueWithoutPassengerInput = {
	where: Prisma.BookingWhereUniqueInput;
	data: Prisma.XOR<
		Prisma.BookingUpdateWithoutPassengerInput,
		Prisma.BookingUncheckedUpdateWithoutPassengerInput
	>;
};

export type BookingUpdateManyWithWhereWithoutPassengerInput = {
	where: Prisma.BookingScalarWhereInput;
	data: Prisma.XOR<
		Prisma.BookingUpdateManyMutationInput,
		Prisma.BookingUncheckedUpdateManyWithoutPassengerInput
	>;
};

export type BookingScalarWhereInput = {
	AND?: Prisma.BookingScalarWhereInput | Prisma.BookingScalarWhereInput[];
	OR?: Prisma.BookingScalarWhereInput[];
	NOT?: Prisma.BookingScalarWhereInput | Prisma.BookingScalarWhereInput[];
	id?: Prisma.StringFilter<"Booking"> | string;
	passengerId?: Prisma.StringFilter<"Booking"> | string;
	driverId?: Prisma.StringNullableFilter<"Booking"> | string | null;
	sourceLat?: Prisma.FloatFilter<"Booking"> | number;
	sourceLong?: Prisma.FloatFilter<"Booking"> | number;
	destLat?: Prisma.FloatFilter<"Booking"> | number;
	destLong?: Prisma.FloatFilter<"Booking"> | number;
	distanceKm?: Prisma.FloatNullableFilter<"Booking"> | number | null;
	fare?: Prisma.IntNullableFilter<"Booking"> | number | null;
	currency?: Prisma.StringFilter<"Booking"> | string;
	status?: Prisma.EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus;
	requestedAt?: Prisma.DateTimeFilter<"Booking"> | Date | string;
	acceptedAt?: Prisma.DateTimeNullableFilter<"Booking"> | Date | string | null;
	startedAt?: Prisma.DateTimeNullableFilter<"Booking"> | Date | string | null;
	completedAt?: Prisma.DateTimeNullableFilter<"Booking"> | Date | string | null;
	cancelledAt?: Prisma.DateTimeNullableFilter<"Booking"> | Date | string | null;
	rating?: Prisma.IntNullableFilter<"Booking"> | number | null;
	feedback?: Prisma.StringNullableFilter<"Booking"> | string | null;
	metadata?: Prisma.JsonNullableFilter<"Booking">;
};

export type BookingUpsertWithWhereUniqueWithoutDriverInput = {
	where: Prisma.BookingWhereUniqueInput;
	update: Prisma.XOR<
		Prisma.BookingUpdateWithoutDriverInput,
		Prisma.BookingUncheckedUpdateWithoutDriverInput
	>;
	create: Prisma.XOR<
		Prisma.BookingCreateWithoutDriverInput,
		Prisma.BookingUncheckedCreateWithoutDriverInput
	>;
};

export type BookingUpdateWithWhereUniqueWithoutDriverInput = {
	where: Prisma.BookingWhereUniqueInput;
	data: Prisma.XOR<
		Prisma.BookingUpdateWithoutDriverInput,
		Prisma.BookingUncheckedUpdateWithoutDriverInput
	>;
};

export type BookingUpdateManyWithWhereWithoutDriverInput = {
	where: Prisma.BookingScalarWhereInput;
	data: Prisma.XOR<
		Prisma.BookingUpdateManyMutationInput,
		Prisma.BookingUncheckedUpdateManyWithoutDriverInput
	>;
};

export type BookingCreateManyPassengerInput = {
	id?: string;
	driverId?: string | null;
	sourceLat: number;
	sourceLong: number;
	destLat: number;
	destLong: number;
	distanceKm?: number | null;
	fare?: number | null;
	currency?: string;
	status?: $Enums.BookingStatus;
	requestedAt?: Date | string;
	acceptedAt?: Date | string | null;
	startedAt?: Date | string | null;
	completedAt?: Date | string | null;
	cancelledAt?: Date | string | null;
	rating?: number | null;
	feedback?: string | null;
	metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
};

export type BookingCreateManyDriverInput = {
	id?: string;
	passengerId: string;
	sourceLat: number;
	sourceLong: number;
	destLat: number;
	destLong: number;
	distanceKm?: number | null;
	fare?: number | null;
	currency?: string;
	status?: $Enums.BookingStatus;
	requestedAt?: Date | string;
	acceptedAt?: Date | string | null;
	startedAt?: Date | string | null;
	completedAt?: Date | string | null;
	cancelledAt?: Date | string | null;
	rating?: number | null;
	feedback?: string | null;
	metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
};

export type BookingUpdateWithoutPassengerInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	sourceLat?: Prisma.FloatFieldUpdateOperationsInput | number;
	sourceLong?: Prisma.FloatFieldUpdateOperationsInput | number;
	destLat?: Prisma.FloatFieldUpdateOperationsInput | number;
	destLong?: Prisma.FloatFieldUpdateOperationsInput | number;
	distanceKm?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	fare?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	currency?: Prisma.StringFieldUpdateOperationsInput | string;
	status?:
		| Prisma.EnumBookingStatusFieldUpdateOperationsInput
		| $Enums.BookingStatus;
	requestedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	acceptedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	startedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	completedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	cancelledAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	rating?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	feedback?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	driver?: Prisma.UserUpdateOneWithoutDriverBookingsNestedInput;
};

export type BookingUncheckedUpdateWithoutPassengerInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	driverId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	sourceLat?: Prisma.FloatFieldUpdateOperationsInput | number;
	sourceLong?: Prisma.FloatFieldUpdateOperationsInput | number;
	destLat?: Prisma.FloatFieldUpdateOperationsInput | number;
	destLong?: Prisma.FloatFieldUpdateOperationsInput | number;
	distanceKm?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	fare?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	currency?: Prisma.StringFieldUpdateOperationsInput | string;
	status?:
		| Prisma.EnumBookingStatusFieldUpdateOperationsInput
		| $Enums.BookingStatus;
	requestedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	acceptedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	startedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	completedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	cancelledAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	rating?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	feedback?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
};

export type BookingUncheckedUpdateManyWithoutPassengerInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	driverId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	sourceLat?: Prisma.FloatFieldUpdateOperationsInput | number;
	sourceLong?: Prisma.FloatFieldUpdateOperationsInput | number;
	destLat?: Prisma.FloatFieldUpdateOperationsInput | number;
	destLong?: Prisma.FloatFieldUpdateOperationsInput | number;
	distanceKm?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	fare?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	currency?: Prisma.StringFieldUpdateOperationsInput | string;
	status?:
		| Prisma.EnumBookingStatusFieldUpdateOperationsInput
		| $Enums.BookingStatus;
	requestedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	acceptedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	startedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	completedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	cancelledAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	rating?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	feedback?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
};

export type BookingUpdateWithoutDriverInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	sourceLat?: Prisma.FloatFieldUpdateOperationsInput | number;
	sourceLong?: Prisma.FloatFieldUpdateOperationsInput | number;
	destLat?: Prisma.FloatFieldUpdateOperationsInput | number;
	destLong?: Prisma.FloatFieldUpdateOperationsInput | number;
	distanceKm?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	fare?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	currency?: Prisma.StringFieldUpdateOperationsInput | string;
	status?:
		| Prisma.EnumBookingStatusFieldUpdateOperationsInput
		| $Enums.BookingStatus;
	requestedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	acceptedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	startedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	completedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	cancelledAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	rating?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	feedback?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
	passenger?: Prisma.UserUpdateOneRequiredWithoutPassengerBookingsNestedInput;
};

export type BookingUncheckedUpdateWithoutDriverInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	passengerId?: Prisma.StringFieldUpdateOperationsInput | string;
	sourceLat?: Prisma.FloatFieldUpdateOperationsInput | number;
	sourceLong?: Prisma.FloatFieldUpdateOperationsInput | number;
	destLat?: Prisma.FloatFieldUpdateOperationsInput | number;
	destLong?: Prisma.FloatFieldUpdateOperationsInput | number;
	distanceKm?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	fare?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	currency?: Prisma.StringFieldUpdateOperationsInput | string;
	status?:
		| Prisma.EnumBookingStatusFieldUpdateOperationsInput
		| $Enums.BookingStatus;
	requestedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	acceptedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	startedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	completedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	cancelledAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	rating?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	feedback?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
};

export type BookingUncheckedUpdateManyWithoutDriverInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	passengerId?: Prisma.StringFieldUpdateOperationsInput | string;
	sourceLat?: Prisma.FloatFieldUpdateOperationsInput | number;
	sourceLong?: Prisma.FloatFieldUpdateOperationsInput | number;
	destLat?: Prisma.FloatFieldUpdateOperationsInput | number;
	destLong?: Prisma.FloatFieldUpdateOperationsInput | number;
	distanceKm?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null;
	fare?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	currency?: Prisma.StringFieldUpdateOperationsInput | string;
	status?:
		| Prisma.EnumBookingStatusFieldUpdateOperationsInput
		| $Enums.BookingStatus;
	requestedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	acceptedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	startedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	completedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	cancelledAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	rating?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	feedback?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	metadata?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
};

export type BookingSelect<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		passengerId?: boolean;
		driverId?: boolean;
		sourceLat?: boolean;
		sourceLong?: boolean;
		destLat?: boolean;
		destLong?: boolean;
		distanceKm?: boolean;
		fare?: boolean;
		currency?: boolean;
		status?: boolean;
		requestedAt?: boolean;
		acceptedAt?: boolean;
		startedAt?: boolean;
		completedAt?: boolean;
		cancelledAt?: boolean;
		rating?: boolean;
		feedback?: boolean;
		metadata?: boolean;
		passenger?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
		driver?: boolean | Prisma.Booking$driverArgs<ExtArgs>;
	},
	ExtArgs["result"]["booking"]
>;

export type BookingSelectCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		passengerId?: boolean;
		driverId?: boolean;
		sourceLat?: boolean;
		sourceLong?: boolean;
		destLat?: boolean;
		destLong?: boolean;
		distanceKm?: boolean;
		fare?: boolean;
		currency?: boolean;
		status?: boolean;
		requestedAt?: boolean;
		acceptedAt?: boolean;
		startedAt?: boolean;
		completedAt?: boolean;
		cancelledAt?: boolean;
		rating?: boolean;
		feedback?: boolean;
		metadata?: boolean;
		passenger?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
		driver?: boolean | Prisma.Booking$driverArgs<ExtArgs>;
	},
	ExtArgs["result"]["booking"]
>;

export type BookingSelectUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		passengerId?: boolean;
		driverId?: boolean;
		sourceLat?: boolean;
		sourceLong?: boolean;
		destLat?: boolean;
		destLong?: boolean;
		distanceKm?: boolean;
		fare?: boolean;
		currency?: boolean;
		status?: boolean;
		requestedAt?: boolean;
		acceptedAt?: boolean;
		startedAt?: boolean;
		completedAt?: boolean;
		cancelledAt?: boolean;
		rating?: boolean;
		feedback?: boolean;
		metadata?: boolean;
		passenger?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
		driver?: boolean | Prisma.Booking$driverArgs<ExtArgs>;
	},
	ExtArgs["result"]["booking"]
>;

export type BookingSelectScalar = {
	id?: boolean;
	passengerId?: boolean;
	driverId?: boolean;
	sourceLat?: boolean;
	sourceLong?: boolean;
	destLat?: boolean;
	destLong?: boolean;
	distanceKm?: boolean;
	fare?: boolean;
	currency?: boolean;
	status?: boolean;
	requestedAt?: boolean;
	acceptedAt?: boolean;
	startedAt?: boolean;
	completedAt?: boolean;
	cancelledAt?: boolean;
	rating?: boolean;
	feedback?: boolean;
	metadata?: boolean;
};

export type BookingOmit<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
	| "id"
	| "passengerId"
	| "driverId"
	| "sourceLat"
	| "sourceLong"
	| "destLat"
	| "destLong"
	| "distanceKm"
	| "fare"
	| "currency"
	| "status"
	| "requestedAt"
	| "acceptedAt"
	| "startedAt"
	| "completedAt"
	| "cancelledAt"
	| "rating"
	| "feedback"
	| "metadata",
	ExtArgs["result"]["booking"]
>;
export type BookingInclude<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	passenger?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
	driver?: boolean | Prisma.Booking$driverArgs<ExtArgs>;
};
export type BookingIncludeCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	passenger?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
	driver?: boolean | Prisma.Booking$driverArgs<ExtArgs>;
};
export type BookingIncludeUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	passenger?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
	driver?: boolean | Prisma.Booking$driverArgs<ExtArgs>;
};

export type $BookingPayload<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	name: "Booking";
	objects: {
		passenger: Prisma.$UserPayload<ExtArgs>;
		driver: Prisma.$UserPayload<ExtArgs> | null;
	};
	scalars: runtime.Types.Extensions.GetPayloadResult<
		{
			id: string;
			passengerId: string;
			driverId: string | null;
			sourceLat: number;
			sourceLong: number;
			destLat: number;
			destLong: number;
			distanceKm: number | null;
			fare: number | null;
			currency: string;
			status: $Enums.BookingStatus;
			requestedAt: Date;
			acceptedAt: Date | null;
			startedAt: Date | null;
			completedAt: Date | null;
			cancelledAt: Date | null;
			rating: number | null;
			feedback: string | null;
			metadata: runtime.JsonValue | null;
		},
		ExtArgs["result"]["booking"]
	>;
	composites: {};
};

export type BookingGetPayload<
	S extends boolean | null | undefined | BookingDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$BookingPayload, S>;

export type BookingCountArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = Omit<BookingFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
	select?: BookingCountAggregateInputType | true;
};

export interface BookingDelegate<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> {
	[K: symbol]: {
		types: Prisma.TypeMap<ExtArgs>["model"]["Booking"];
		meta: { name: "Booking" };
	};
	/**
	 * Find zero or one Booking that matches the filter.
	 * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
	 * @example
	 * // Get one Booking
	 * const booking = await prisma.booking.findUnique({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUnique<T extends BookingFindUniqueArgs>(
		args: Prisma.SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>,
	): Prisma.Prisma__BookingClient<
		runtime.Types.Result.GetResult<
			Prisma.$BookingPayload<ExtArgs>,
			T,
			"findUnique",
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find one Booking that matches the filter or throw an error with `error.code='P2025'`
	 * if no matches were found.
	 * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
	 * @example
	 * // Get one Booking
	 * const booking = await prisma.booking.findUniqueOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(
		args: Prisma.SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__BookingClient<
		runtime.Types.Result.GetResult<
			Prisma.$BookingPayload<ExtArgs>,
			T,
			"findUniqueOrThrow",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first Booking that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {BookingFindFirstArgs} args - Arguments to find a Booking
	 * @example
	 * // Get one Booking
	 * const booking = await prisma.booking.findFirst({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirst<T extends BookingFindFirstArgs>(
		args?: Prisma.SelectSubset<T, BookingFindFirstArgs<ExtArgs>>,
	): Prisma.Prisma__BookingClient<
		runtime.Types.Result.GetResult<
			Prisma.$BookingPayload<ExtArgs>,
			T,
			"findFirst",
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first Booking that matches the filter or
	 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
	 * @example
	 * // Get one Booking
	 * const booking = await prisma.booking.findFirstOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(
		args?: Prisma.SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__BookingClient<
		runtime.Types.Result.GetResult<
			Prisma.$BookingPayload<ExtArgs>,
			T,
			"findFirstOrThrow",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find zero or more Bookings that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
	 * @example
	 * // Get all Bookings
	 * const bookings = await prisma.booking.findMany()
	 *
	 * // Get first 10 Bookings
	 * const bookings = await prisma.booking.findMany({ take: 10 })
	 *
	 * // Only select the `id`
	 * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
	 *
	 */
	findMany<T extends BookingFindManyArgs>(
		args?: Prisma.SelectSubset<T, BookingFindManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$BookingPayload<ExtArgs>,
			T,
			"findMany",
			GlobalOmitOptions
		>
	>;

	/**
	 * Create a Booking.
	 * @param {BookingCreateArgs} args - Arguments to create a Booking.
	 * @example
	 * // Create one Booking
	 * const Booking = await prisma.booking.create({
	 *   data: {
	 *     // ... data to create a Booking
	 *   }
	 * })
	 *
	 */
	create<T extends BookingCreateArgs>(
		args: Prisma.SelectSubset<T, BookingCreateArgs<ExtArgs>>,
	): Prisma.Prisma__BookingClient<
		runtime.Types.Result.GetResult<
			Prisma.$BookingPayload<ExtArgs>,
			T,
			"create",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Create many Bookings.
	 * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
	 * @example
	 * // Create many Bookings
	 * const booking = await prisma.booking.createMany({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 */
	createMany<T extends BookingCreateManyArgs>(
		args?: Prisma.SelectSubset<T, BookingCreateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Create many Bookings and returns the data saved in the database.
	 * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
	 * @example
	 * // Create many Bookings
	 * const booking = await prisma.booking.createManyAndReturn({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Create many Bookings and only return the `id`
	 * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({
	 *   select: { id: true },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 *
	 */
	createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(
		args?: Prisma.SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$BookingPayload<ExtArgs>,
			T,
			"createManyAndReturn",
			GlobalOmitOptions
		>
	>;

	/**
	 * Delete a Booking.
	 * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
	 * @example
	 * // Delete one Booking
	 * const Booking = await prisma.booking.delete({
	 *   where: {
	 *     // ... filter to delete one Booking
	 *   }
	 * })
	 *
	 */
	delete<T extends BookingDeleteArgs>(
		args: Prisma.SelectSubset<T, BookingDeleteArgs<ExtArgs>>,
	): Prisma.Prisma__BookingClient<
		runtime.Types.Result.GetResult<
			Prisma.$BookingPayload<ExtArgs>,
			T,
			"delete",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Update one Booking.
	 * @param {BookingUpdateArgs} args - Arguments to update one Booking.
	 * @example
	 * // Update one Booking
	 * const booking = await prisma.booking.update({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	update<T extends BookingUpdateArgs>(
		args: Prisma.SelectSubset<T, BookingUpdateArgs<ExtArgs>>,
	): Prisma.Prisma__BookingClient<
		runtime.Types.Result.GetResult<
			Prisma.$BookingPayload<ExtArgs>,
			T,
			"update",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Delete zero or more Bookings.
	 * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
	 * @example
	 * // Delete a few Bookings
	 * const { count } = await prisma.booking.deleteMany({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 *
	 */
	deleteMany<T extends BookingDeleteManyArgs>(
		args?: Prisma.SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Update zero or more Bookings.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
	 * @example
	 * // Update many Bookings
	 * const booking = await prisma.booking.updateMany({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	updateMany<T extends BookingUpdateManyArgs>(
		args: Prisma.SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Update zero or more Bookings and returns the data updated in the database.
	 * @param {BookingUpdateManyAndReturnArgs} args - Arguments to update many Bookings.
	 * @example
	 * // Update many Bookings
	 * const booking = await prisma.booking.updateManyAndReturn({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Update zero or more Bookings and only return the `id`
	 * const bookingWithIdOnly = await prisma.booking.updateManyAndReturn({
	 *   select: { id: true },
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 *
	 */
	updateManyAndReturn<T extends BookingUpdateManyAndReturnArgs>(
		args: Prisma.SelectSubset<T, BookingUpdateManyAndReturnArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$BookingPayload<ExtArgs>,
			T,
			"updateManyAndReturn",
			GlobalOmitOptions
		>
	>;

	/**
	 * Create or update one Booking.
	 * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
	 * @example
	 * // Update or create a Booking
	 * const booking = await prisma.booking.upsert({
	 *   create: {
	 *     // ... data to create a Booking
	 *   },
	 *   update: {
	 *     // ... in case it already exists, update
	 *   },
	 *   where: {
	 *     // ... the filter for the Booking we want to update
	 *   }
	 * })
	 */
	upsert<T extends BookingUpsertArgs>(
		args: Prisma.SelectSubset<T, BookingUpsertArgs<ExtArgs>>,
	): Prisma.Prisma__BookingClient<
		runtime.Types.Result.GetResult<
			Prisma.$BookingPayload<ExtArgs>,
			T,
			"upsert",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Count the number of Bookings.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
	 * @example
	 * // Count the number of Bookings
	 * const count = await prisma.booking.count({
	 *   where: {
	 *     // ... the filter for the Bookings we want to count
	 *   }
	 * })
	 **/
	count<T extends BookingCountArgs>(
		args?: Prisma.Subset<T, BookingCountArgs>,
	): Prisma.PrismaPromise<
		T extends runtime.Types.Utils.Record<"select", any>
			? T["select"] extends true
				? number
				: Prisma.GetScalarType<T["select"], BookingCountAggregateOutputType>
			: number
	>;

	/**
	 * Allows you to perform aggregations operations on a Booking.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
	 * @example
	 * // Ordered by age ascending
	 * // Where email contains prisma.io
	 * // Limited to the 10 users
	 * const aggregations = await prisma.user.aggregate({
	 *   _avg: {
	 *     age: true,
	 *   },
	 *   where: {
	 *     email: {
	 *       contains: "prisma.io",
	 *     },
	 *   },
	 *   orderBy: {
	 *     age: "asc",
	 *   },
	 *   take: 10,
	 * })
	 **/
	aggregate<T extends BookingAggregateArgs>(
		args: Prisma.Subset<T, BookingAggregateArgs>,
	): Prisma.PrismaPromise<GetBookingAggregateType<T>>;

	/**
	 * Group by Booking.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {BookingGroupByArgs} args - Group by arguments.
	 * @example
	 * // Group by city, order by createdAt, get count
	 * const result = await prisma.user.groupBy({
	 *   by: ['city', 'createdAt'],
	 *   orderBy: {
	 *     createdAt: true
	 *   },
	 *   _count: {
	 *     _all: true
	 *   },
	 * })
	 *
	 **/
	groupBy<
		T extends BookingGroupByArgs,
		HasSelectOrTake extends Prisma.Or<
			Prisma.Extends<"skip", Prisma.Keys<T>>,
			Prisma.Extends<"take", Prisma.Keys<T>>
		>,
		OrderByArg extends Prisma.True extends HasSelectOrTake
			? { orderBy: BookingGroupByArgs["orderBy"] }
			: { orderBy?: BookingGroupByArgs["orderBy"] },
		OrderFields extends Prisma.ExcludeUnderscoreKeys<
			Prisma.Keys<Prisma.MaybeTupleToUnion<T["orderBy"]>>
		>,
		ByFields extends Prisma.MaybeTupleToUnion<T["by"]>,
		ByValid extends Prisma.Has<ByFields, OrderFields>,
		HavingFields extends Prisma.GetHavingFields<T["having"]>,
		HavingValid extends Prisma.Has<ByFields, HavingFields>,
		ByEmpty extends T["by"] extends never[] ? Prisma.True : Prisma.False,
		InputErrors extends ByEmpty extends Prisma.True
			? `Error: "by" must not be empty.`
			: HavingValid extends Prisma.False
				? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
										Error,
										"Field ",
										P,
										` in "having" needs to be provided in "by"`,
									];
					}[HavingFields]
				: "take" extends Prisma.Keys<T>
					? "orderBy" extends Prisma.Keys<T>
						? ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields]
						: 'Error: If you provide "take", you also need to provide "orderBy"'
					: "skip" extends Prisma.Keys<T>
						? "orderBy" extends Prisma.Keys<T>
							? ByValid extends Prisma.True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
									}[OrderFields]
							: 'Error: If you provide "skip", you also need to provide "orderBy"'
						: ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields],
	>(
		args: Prisma.SubsetIntersection<T, BookingGroupByArgs, OrderByArg> &
			InputErrors,
	): {} extends InputErrors
		? GetBookingGroupByPayload<T>
		: Prisma.PrismaPromise<InputErrors>;
	/**
	 * Fields of the Booking model
	 */
	readonly fields: BookingFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Booking.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__BookingClient<
	T,
	Null = never,
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
	readonly [Symbol.toStringTag]: "PrismaPromise";
	passenger<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>,
	): Prisma.Prisma__UserClient<
		| runtime.Types.Result.GetResult<
				Prisma.$UserPayload<ExtArgs>,
				T,
				"findUniqueOrThrow",
				GlobalOmitOptions
		  >
		| Null,
		Null,
		ExtArgs,
		GlobalOmitOptions
	>;
	driver<T extends Prisma.Booking$driverArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Booking$driverArgs<ExtArgs>>,
	): Prisma.Prisma__UserClient<
		runtime.Types.Result.GetResult<
			Prisma.$UserPayload<ExtArgs>,
			T,
			"findUniqueOrThrow",
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;
	/**
	 * Attaches callbacks for the resolution and/or rejection of the Promise.
	 * @param onfulfilled The callback to execute when the Promise is resolved.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of which ever callback is executed.
	 */
	then<TResult1 = T, TResult2 = never>(
		onfulfilled?:
			| ((value: T) => TResult1 | PromiseLike<TResult1>)
			| undefined
			| null,
		onrejected?:
			| ((reason: any) => TResult2 | PromiseLike<TResult2>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
	/**
	 * Attaches a callback for only the rejection of the Promise.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of the callback.
	 */
	catch<TResult = never>(
		onrejected?:
			| ((reason: any) => TResult | PromiseLike<TResult>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<T | TResult>;
	/**
	 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
	 * resolved value cannot be modified from the callback.
	 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
	 * @returns A Promise for the completion of the callback.
	 */
	finally(
		onfinally?: (() => void) | undefined | null,
	): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the Booking model
 */
export interface BookingFieldRefs {
	readonly id: Prisma.FieldRef<"Booking", "String">;
	readonly passengerId: Prisma.FieldRef<"Booking", "String">;
	readonly driverId: Prisma.FieldRef<"Booking", "String">;
	readonly sourceLat: Prisma.FieldRef<"Booking", "Float">;
	readonly sourceLong: Prisma.FieldRef<"Booking", "Float">;
	readonly destLat: Prisma.FieldRef<"Booking", "Float">;
	readonly destLong: Prisma.FieldRef<"Booking", "Float">;
	readonly distanceKm: Prisma.FieldRef<"Booking", "Float">;
	readonly fare: Prisma.FieldRef<"Booking", "Int">;
	readonly currency: Prisma.FieldRef<"Booking", "String">;
	readonly status: Prisma.FieldRef<"Booking", "BookingStatus">;
	readonly requestedAt: Prisma.FieldRef<"Booking", "DateTime">;
	readonly acceptedAt: Prisma.FieldRef<"Booking", "DateTime">;
	readonly startedAt: Prisma.FieldRef<"Booking", "DateTime">;
	readonly completedAt: Prisma.FieldRef<"Booking", "DateTime">;
	readonly cancelledAt: Prisma.FieldRef<"Booking", "DateTime">;
	readonly rating: Prisma.FieldRef<"Booking", "Int">;
	readonly feedback: Prisma.FieldRef<"Booking", "String">;
	readonly metadata: Prisma.FieldRef<"Booking", "Json">;
}

// Custom InputTypes
/**
 * Booking findUnique
 */
export type BookingFindUniqueArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Booking
	 */
	select?: Prisma.BookingSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Booking
	 */
	omit?: Prisma.BookingOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.BookingInclude<ExtArgs> | null;
	/**
	 * Filter, which Booking to fetch.
	 */
	where: Prisma.BookingWhereUniqueInput;
};

/**
 * Booking findUniqueOrThrow
 */
export type BookingFindUniqueOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Booking
	 */
	select?: Prisma.BookingSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Booking
	 */
	omit?: Prisma.BookingOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.BookingInclude<ExtArgs> | null;
	/**
	 * Filter, which Booking to fetch.
	 */
	where: Prisma.BookingWhereUniqueInput;
};

/**
 * Booking findFirst
 */
export type BookingFindFirstArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Booking
	 */
	select?: Prisma.BookingSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Booking
	 */
	omit?: Prisma.BookingOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.BookingInclude<ExtArgs> | null;
	/**
	 * Filter, which Booking to fetch.
	 */
	where?: Prisma.BookingWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Bookings to fetch.
	 */
	orderBy?:
		| Prisma.BookingOrderByWithRelationInput
		| Prisma.BookingOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for Bookings.
	 */
	cursor?: Prisma.BookingWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Bookings from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Bookings.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of Bookings.
	 */
	distinct?: Prisma.BookingScalarFieldEnum | Prisma.BookingScalarFieldEnum[];
};

/**
 * Booking findFirstOrThrow
 */
export type BookingFindFirstOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Booking
	 */
	select?: Prisma.BookingSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Booking
	 */
	omit?: Prisma.BookingOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.BookingInclude<ExtArgs> | null;
	/**
	 * Filter, which Booking to fetch.
	 */
	where?: Prisma.BookingWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Bookings to fetch.
	 */
	orderBy?:
		| Prisma.BookingOrderByWithRelationInput
		| Prisma.BookingOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for Bookings.
	 */
	cursor?: Prisma.BookingWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Bookings from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Bookings.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of Bookings.
	 */
	distinct?: Prisma.BookingScalarFieldEnum | Prisma.BookingScalarFieldEnum[];
};

/**
 * Booking findMany
 */
export type BookingFindManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Booking
	 */
	select?: Prisma.BookingSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Booking
	 */
	omit?: Prisma.BookingOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.BookingInclude<ExtArgs> | null;
	/**
	 * Filter, which Bookings to fetch.
	 */
	where?: Prisma.BookingWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Bookings to fetch.
	 */
	orderBy?:
		| Prisma.BookingOrderByWithRelationInput
		| Prisma.BookingOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for listing Bookings.
	 */
	cursor?: Prisma.BookingWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Bookings from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Bookings.
	 */
	skip?: number;
	distinct?: Prisma.BookingScalarFieldEnum | Prisma.BookingScalarFieldEnum[];
};

/**
 * Booking create
 */
export type BookingCreateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Booking
	 */
	select?: Prisma.BookingSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Booking
	 */
	omit?: Prisma.BookingOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.BookingInclude<ExtArgs> | null;
	/**
	 * The data needed to create a Booking.
	 */
	data: Prisma.XOR<
		Prisma.BookingCreateInput,
		Prisma.BookingUncheckedCreateInput
	>;
};

/**
 * Booking createMany
 */
export type BookingCreateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to create many Bookings.
	 */
	data: Prisma.BookingCreateManyInput | Prisma.BookingCreateManyInput[];
	skipDuplicates?: boolean;
};

/**
 * Booking createManyAndReturn
 */
export type BookingCreateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Booking
	 */
	select?: Prisma.BookingSelectCreateManyAndReturn<ExtArgs> | null;
	/**
	 * Omit specific fields from the Booking
	 */
	omit?: Prisma.BookingOmit<ExtArgs> | null;
	/**
	 * The data used to create many Bookings.
	 */
	data: Prisma.BookingCreateManyInput | Prisma.BookingCreateManyInput[];
	skipDuplicates?: boolean;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.BookingIncludeCreateManyAndReturn<ExtArgs> | null;
};

/**
 * Booking update
 */
export type BookingUpdateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Booking
	 */
	select?: Prisma.BookingSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Booking
	 */
	omit?: Prisma.BookingOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.BookingInclude<ExtArgs> | null;
	/**
	 * The data needed to update a Booking.
	 */
	data: Prisma.XOR<
		Prisma.BookingUpdateInput,
		Prisma.BookingUncheckedUpdateInput
	>;
	/**
	 * Choose, which Booking to update.
	 */
	where: Prisma.BookingWhereUniqueInput;
};

/**
 * Booking updateMany
 */
export type BookingUpdateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to update Bookings.
	 */
	data: Prisma.XOR<
		Prisma.BookingUpdateManyMutationInput,
		Prisma.BookingUncheckedUpdateManyInput
	>;
	/**
	 * Filter which Bookings to update
	 */
	where?: Prisma.BookingWhereInput;
	/**
	 * Limit how many Bookings to update.
	 */
	limit?: number;
};

/**
 * Booking updateManyAndReturn
 */
export type BookingUpdateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Booking
	 */
	select?: Prisma.BookingSelectUpdateManyAndReturn<ExtArgs> | null;
	/**
	 * Omit specific fields from the Booking
	 */
	omit?: Prisma.BookingOmit<ExtArgs> | null;
	/**
	 * The data used to update Bookings.
	 */
	data: Prisma.XOR<
		Prisma.BookingUpdateManyMutationInput,
		Prisma.BookingUncheckedUpdateManyInput
	>;
	/**
	 * Filter which Bookings to update
	 */
	where?: Prisma.BookingWhereInput;
	/**
	 * Limit how many Bookings to update.
	 */
	limit?: number;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.BookingIncludeUpdateManyAndReturn<ExtArgs> | null;
};

/**
 * Booking upsert
 */
export type BookingUpsertArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Booking
	 */
	select?: Prisma.BookingSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Booking
	 */
	omit?: Prisma.BookingOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.BookingInclude<ExtArgs> | null;
	/**
	 * The filter to search for the Booking to update in case it exists.
	 */
	where: Prisma.BookingWhereUniqueInput;
	/**
	 * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
	 */
	create: Prisma.XOR<
		Prisma.BookingCreateInput,
		Prisma.BookingUncheckedCreateInput
	>;
	/**
	 * In case the Booking was found with the provided `where` argument, update it with this data.
	 */
	update: Prisma.XOR<
		Prisma.BookingUpdateInput,
		Prisma.BookingUncheckedUpdateInput
	>;
};

/**
 * Booking delete
 */
export type BookingDeleteArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Booking
	 */
	select?: Prisma.BookingSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Booking
	 */
	omit?: Prisma.BookingOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.BookingInclude<ExtArgs> | null;
	/**
	 * Filter which Booking to delete.
	 */
	where: Prisma.BookingWhereUniqueInput;
};

/**
 * Booking deleteMany
 */
export type BookingDeleteManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which Bookings to delete
	 */
	where?: Prisma.BookingWhereInput;
	/**
	 * Limit how many Bookings to delete.
	 */
	limit?: number;
};

/**
 * Booking.driver
 */
export type Booking$driverArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the User
	 */
	select?: Prisma.UserSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the User
	 */
	omit?: Prisma.UserOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.UserInclude<ExtArgs> | null;
	where?: Prisma.UserWhereInput;
};

/**
 * Booking without action
 */
export type BookingDefaultArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Booking
	 */
	select?: Prisma.BookingSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Booking
	 */
	omit?: Prisma.BookingOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.BookingInclude<ExtArgs> | null;
};
